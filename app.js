const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const fs = require('fs');
const net = require('net');

const app = express();
const PORT = process.env.PORT || 8080;

// Railway –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
const TCP_DOMAIN = process.env.RAILWAY_TCP_PROXY_DOMAIN;
const TCP_PORT = process.env.RAILWAY_TCP_PROXY_PORT;
const PUBLIC_DOMAIN = process.env.RAILWAY_PUBLIC_DOMAIN;

const CONFIG_FILE = './clients-config.json';
const BLACKLIST_FILE = './ip-blacklist.json';

// Middleware
app.use(express.json());

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
let clientsConfig = {};
let ipBlacklist = new Set();
let proxyRotation = {};

// –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
function loadConfig() {
  try {
    if (fs.existsSync(CONFIG_FILE)) {
      const data = fs.readFileSync(CONFIG_FILE, 'utf8');
      clientsConfig = JSON.parse(data);
      console.log(`‚úÖ Configuration loaded: ${Object.keys(clientsConfig).length} clients`);
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–æ—Ç–∞—Ü–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
      Object.keys(clientsConfig).forEach(username => {
        if (clientsConfig[username].proxies && clientsConfig[username].proxies.length > 0) {
          proxyRotation[username] = { currentIndex: 0 };
        }
      });
    } else {
      console.log('üìù No config file found, using empty configuration');
      clientsConfig = {};
    }
  } catch (error) {
    console.error('‚ùå Error loading config:', error);
    clientsConfig = {};
  }
}

// –ó–∞–≥—Ä—É–∑–∫–∞ –±–ª—ç–∫–ª–∏—Å—Ç–∞
function loadBlacklist() {
  try {
    if (fs.existsSync(BLACKLIST_FILE)) {
      const data = fs.readFileSync(BLACKLIST_FILE, 'utf8');
      const blacklistArray = JSON.parse(data);
      ipBlacklist = new Set(blacklistArray);
      console.log(`üö´ Blacklist loaded: ${ipBlacklist.size} IPs`);
    }
  } catch (error) {
    console.error('‚ùå Error loading blacklist:', error);
    ipBlacklist = new Set();
  }
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
function saveConfig() {
  try {
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(clientsConfig, null, 2));
    console.log('üíæ Configuration saved');
  } catch (error) {
    console.error('‚ùå Error saving config:', error);
  }
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–ª—ç–∫–ª–∏—Å—Ç–∞
function saveBlacklist() {
  try {
    fs.writeFileSync(BLACKLIST_FILE, JSON.stringify([...ipBlacklist], null, 2));
    console.log('üíæ Blacklist saved');
  } catch (error) {
    console.error('‚ùå Error saving blacklist:', error);
  }
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ IP
function getClientIP(req) {
  return req.headers['x-forwarded-for']?.split(',')[0]?.trim() ||
         req.headers['x-real-ip'] ||
         req.connection.remoteAddress ||
         req.socket.remoteAddress ||
         req.ip;
}

// –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞
function authenticateClient(req, res, next) {
  const clientIP = getClientIP(req);
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–ª—ç–∫–ª–∏—Å—Ç–∞
  if (ipBlacklist.has(clientIP)) {
    console.log(`üö´ Blocked IP: ${clientIP}`);
    return res.status(403).json({ error: 'Access denied' });
  }

  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Basic ')) {
    return res.status(401).json({ error: 'Authentication required' });
  }

  const credentials = Buffer.from(auth.slice(6), 'base64').toString();
  const [username, password] = credentials.split(':');

  if (!clientsConfig[username] || clientsConfig[username].password !== password) {
    console.log(`‚ùå Auth failed: ${username} from ${clientIP}`);
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  req.clientUsername = username;
  req.clientIP = clientIP;
  console.log(`‚úÖ Auth success: ${username} from ${clientIP}`);
  next();
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø—Ä–æ–∫—Å–∏ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞
function getNextProxy(username) {
  const client = clientsConfig[username];
  if (!client || !client.proxies || client.proxies.length === 0) {
    return null;
  }

  if (!proxyRotation[username]) {
    proxyRotation[username] = { currentIndex: 0 };
  }

  const proxy = client.proxies[proxyRotation[username].currentIndex];
  proxyRotation[username].currentIndex = 
    (proxyRotation[username].currentIndex + 1) % client.proxies.length;

  return proxy;
}

// –ü–∞—Ä—Å–∏–Ω–≥ –ø—Ä–æ–∫—Å–∏ —Å—Ç—Ä–æ–∫–∏
function parseProxy(proxyString) {
  const parts = proxyString.split(':');
  if (parts.length >= 4) {
    return {
      host: parts[0],
      port: parseInt(parts[1]),
      username: parts[2],
      password: parts[3]
    };
  }
  return null;
}

// API Endpoints

// –°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞
app.get('/status', (req, res) => {
  const stats = {
    status: 'running',
    port: PORT,
    tcp_proxy: `${TCP_DOMAIN}:${TCP_PORT}`,
    public_domain: PUBLIC_DOMAIN,
    uptime: process.uptime(),
    clients: Object.keys(clientsConfig).length,
    blacklisted_ips: ipBlacklist.size,
    timestamp: new Date().toISOString()
  };

  // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∫–ª–∏–µ–Ω—Ç–∞–º
  stats.client_stats = {};
  Object.keys(clientsConfig).forEach(username => {
    const client = clientsConfig[username];
    stats.client_stats[username] = {
      proxies: client.proxies ? client.proxies.length : 0,
      current_proxy_index: proxyRotation[username]?.currentIndex || 0
    };
  });

  res.json(stats);
});

// Health check
app.get('/health', (req, res) => {
  res.status(200).send('OK');
});

// –ü–æ–ª—É—á–∏—Ç—å IP –∫–ª–∏–µ–Ω—Ç–∞
app.get('/myip', (req, res) => {
  const clientIP = getClientIP(req);
  res.set({
    'Content-Type': 'text/plain',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  res.send(clientIP);
});

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –æ—Ç Telegram –±–æ—Ç–∞
app.post('/update-config', (req, res) => {
  try {
    const { clients } = req.body;
    
    if (!clients || typeof clients !== 'object') {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid clients configuration' 
      });
    }

    clientsConfig = clients;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–æ—Ç–∞—Ü–∏—é –¥–ª—è –Ω–æ–≤—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
    Object.keys(clientsConfig).forEach(username => {
      if (clientsConfig[username].proxies && clientsConfig[username].proxies.length > 0) {
        if (!proxyRotation[username]) {
          proxyRotation[username] = { currentIndex: 0 };
        }
      }
    });

    saveConfig();
    console.log('üì• Configuration received from Telegram Bot');
    console.log(`‚úÖ Updated configuration: ${Object.keys(clientsConfig).length} clients`);
    
    res.json({ 
      success: true, 
      message: 'Configuration updated successfully',
      clients: Object.keys(clientsConfig).length
    });
  } catch (error) {
    console.error('‚ùå Error updating config:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ø—Ä–æ–∫—Å–∏ endpoint —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π
app.use('/proxy', authenticateClient, (req, res, next) => {
  const username = req.clientUsername;
  const proxy = getNextProxy(username);
  
  if (!proxy) {
    return res.status(503).json({ 
      error: 'No proxies available for this client' 
    });
  }

  const parsedProxy = parseProxy(proxy);
  if (!parsedProxy) {
    return res.status(500).json({ 
      error: 'Invalid proxy configuration' 
    });
  }

  console.log(`üîÑ Using proxy for ${username}: ${parsedProxy.host}:${parsedProxy.port}`);

  // ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–´–ô —Å–ø–æ—Å–æ–± –ø–µ—Ä–µ–¥–∞—á–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø—Ä–æ–∫—Å–∏
  const proxyMiddleware = createProxyMiddleware({
    target: `http://${parsedProxy.host}:${parsedProxy.port}`,
    changeOrigin: true,
    pathRewrite: {
      '^/proxy': ''
    },
    onError: (err, req, res) => {
      console.error(`‚ùå Proxy error for ${username}:`, err.message);
      res.status(502).json({ error: 'Proxy connection failed' });
    },
    onProxyReq: (proxyReq, req, res) => {
      // ‚úÖ –î–æ–±–∞–≤–ª—è–µ–º Proxy-Authorization header –¥–ª—è upstream –ø—Ä–æ–∫—Å–∏
      const proxyAuth = Buffer.from(`${parsedProxy.username}:${parsedProxy.password}`).toString('base64');
      proxyReq.setHeader('Proxy-Authorization', `Basic ${proxyAuth}`);
      
      console.log(`‚û°Ô∏è Proxying ${req.method} ${req.url} for ${username} via ${parsedProxy.host}:${parsedProxy.port}`);
    }
  });

  proxyMiddleware(req, res, next);
});

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–ª—ç–∫–ª–∏—Å—Ç–æ–º (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
app.post('/blacklist/add', (req, res) => {
  const { ip, admin_key } = req.body;
  
  // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω –∫–ª—é—á–∞ (–≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–æ–ª–µ–µ –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –º–µ—Ç–æ–¥)
  if (admin_key !== process.env.ADMIN_KEY) {
    return res.status(403).json({ error: 'Admin access required' });
  }

  if (!ip) {
    return res.status(400).json({ error: 'IP address required' });
  }

  ipBlacklist.add(ip);
  saveBlacklist();
  console.log(`üö´ Added to blacklist: ${ip}`);
  
  res.json({ success: true, message: `IP ${ip} added to blacklist` });
});

app.post('/blacklist/remove', (req, res) => {
  const { ip, admin_key } = req.body;
  
  if (admin_key !== process.env.ADMIN_KEY) {
    return res.status(403).json({ error: 'Admin access required' });
  }

  if (!ip) {
    return res.status(400).json({ error: 'IP address required' });
  }

  ipBlacklist.delete(ip);
  saveBlacklist();
  console.log(`‚úÖ Removed from blacklist: ${ip}`);
  
  res.json({ success: true, message: `IP ${ip} removed from blacklist` });
});

// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –±–ª—ç–∫–ª–∏—Å—Ç–∞
app.get('/blacklist', (req, res) => {
  const { admin_key } = req.query;
  
  if (admin_key !== process.env.ADMIN_KEY) {
    return res.status(403).json({ error: 'Admin access required' });
  }

  res.json({ blacklist: [...ipBlacklist] });
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ FIXED Proxy server with correct auth running on port ${PORT}`);
  console.log(`üåê TCP Proxy: ${TCP_DOMAIN}:${TCP_PORT}`);
  console.log(`üåê Public Domain: ${PUBLIC_DOMAIN}`);
  console.log('ü§ñ Managed by Telegram Bot');
  console.log('üî• Hot reload: ENABLED');
  console.log('‚úÖ Proxy-Authorization header: FIXED');
  console.log('‚ö° Concurrent mode: NO rotation locks');
  console.log('‚úÖ Server started successfully');
  
  // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
  loadConfig();
  loadBlacklist();
  
  console.log('üîç Overlapping proxies: 0');
  console.log('‚úÖ Fully isolated proxy pools - safe for concurrent rotation');
});
