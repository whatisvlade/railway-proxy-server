const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const fs = require('fs');
const http = require('http');
const net = require('net');

const app = express();
const PORT = process.env.PORT || 8080;

// Railway –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
const TCP_DOMAIN = process.env.RAILWAY_TCP_PROXY_DOMAIN;
const TCP_PORT = process.env.RAILWAY_TCP_PROXY_PORT;
const PUBLIC_DOMAIN = process.env.RAILWAY_PUBLIC_DOMAIN;

const CONFIG_FILE = './clients-config.json';
const BLACKLIST_FILE = './ip-blacklist.json';

// Middleware
app.use(express.json());

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
let clientsConfig = {};
let ipBlacklist = new Set();
let proxyRotation = {};

// –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
function loadConfig() {
  try {
    if (fs.existsSync(CONFIG_FILE)) {
      const data = fs.readFileSync(CONFIG_FILE, 'utf8');
      clientsConfig = JSON.parse(data);
      console.log(`‚úÖ Configuration loaded: ${Object.keys(clientsConfig).length} clients`);
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–æ—Ç–∞—Ü–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
      Object.keys(clientsConfig).forEach(username => {
        if (clientsConfig[username].proxies && clientsConfig[username].proxies.length > 0) {
          proxyRotation[username] = { currentIndex: 0 };
        }
      });
    } else {
      console.log('üìù No config file found, using empty configuration');
      clientsConfig = {};
    }
  } catch (error) {
    console.error('‚ùå Error loading config:', error);
    clientsConfig = {};
  }
}

// –ó–∞–≥—Ä—É–∑–∫–∞ –±–ª—ç–∫–ª–∏—Å—Ç–∞
function loadBlacklist() {
  try {
    if (fs.existsSync(BLACKLIST_FILE)) {
      const data = fs.readFileSync(BLACKLIST_FILE, 'utf8');
      const blacklistArray = JSON.parse(data);
      ipBlacklist = new Set(blacklistArray);
      console.log(`üö´ Blacklist loaded: ${ipBlacklist.size} IPs`);
    }
  } catch (error) {
    console.error('‚ùå Error loading blacklist:', error);
    ipBlacklist = new Set();
  }
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
function saveConfig() {
  try {
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(clientsConfig, null, 2));
    console.log('üíæ Configuration saved');
  } catch (error) {
    console.error('‚ùå Error saving config:', error);
  }
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–ª—ç–∫–ª–∏—Å—Ç–∞
function saveBlacklist() {
  try {
    fs.writeFileSync(BLACKLIST_FILE, JSON.stringify([...ipBlacklist], null, 2));
    console.log('üíæ Blacklist saved');
  } catch (error) {
    console.error('‚ùå Error saving blacklist:', error);
  }
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ IP
function getClientIP(req) {
  return req.headers['x-forwarded-for']?.split(',')[0]?.trim() ||
         req.headers['x-real-ip'] ||
         req.connection.remoteAddress ||
         req.socket.remoteAddress ||
         req.ip;
}

// –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞
function authenticateClient(req, res, next) {
  const clientIP = getClientIP(req);
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–ª—ç–∫–ª–∏—Å—Ç–∞
  if (ipBlacklist.has(clientIP)) {
    console.log(`üö´ Blocked IP: ${clientIP}`);
    return res.status(403).json({ error: 'Access denied' });
  }

  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Basic ')) {
    return res.status(401).json({ error: 'Authentication required' });
  }

  const credentials = Buffer.from(auth.slice(6), 'base64').toString();
  const [username, password] = credentials.split(':');

  if (!clientsConfig[username] || clientsConfig[username].password !== password) {
    console.log(`‚ùå Auth failed: ${username} from ${clientIP}`);
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  req.clientUsername = username;
  req.clientIP = clientIP;
  console.log(`‚úÖ Auth success: ${username} from ${clientIP}`);
  next();
}

// ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –¥–ª—è CONNECT –∑–∞–ø—Ä–æ—Å–æ–≤
function authenticateConnect(req) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
  const auth = req.headers['proxy-authorization'] || 
               req.headers['authorization'] ||
               req.headers['Proxy-Authorization'] ||
               req.headers['Authorization'];
               
  console.log(`üîç CONNECT Auth attempt for: ${req.url}`);
  console.log(`üîç Available headers:`, Object.keys(req.headers).filter(h => h.toLowerCase().includes('auth')));
  
  if (!auth) {
    console.log('‚ùå CONNECT: No auth header found');
    return null;
  }

  let credentials;
  if (auth.startsWith('Basic ')) {
    credentials = Buffer.from(auth.slice(6), 'base64').toString();
  } else {
    // –í–æ–∑–º–æ–∂–Ω–æ auth —É–∂–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω –∏–ª–∏ –≤ –¥—Ä—É–≥–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
    credentials = auth;
  }

  const [username, password] = credentials.split(':');
  console.log(`üîç CONNECT: Trying user: ${username}`);

  if (!clientsConfig[username] || clientsConfig[username].password !== password) {
    console.log(`‚ùå CONNECT: Invalid credentials for ${username}`);
    console.log(`üîç Available clients:`, Object.keys(clientsConfig));
    return null;
  }

  console.log(`‚úÖ CONNECT: Success for ${username}`);
  return username;
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø—Ä–æ–∫—Å–∏ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–æ—Ç–∞—Ü–∏—è)
function getNextProxy(username) {
  const client = clientsConfig[username];
  if (!client || !client.proxies || client.proxies.length === 0) {
    return null;
  }

  if (!proxyRotation[username]) {
    proxyRotation[username] = { currentIndex: 0 };
  }

  const proxy = client.proxies[proxyRotation[username].currentIndex];
  proxyRotation[username].currentIndex = 
    (proxyRotation[username].currentIndex + 1) % client.proxies.length;

  return proxy;
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –ø—Ä–æ–∫—Å–∏ –±–µ–∑ —Ä–æ—Ç–∞—Ü–∏–∏
function getCurrentProxy(username) {
  const client = clientsConfig[username];
  if (!client || !client.proxies || client.proxies.length === 0) {
    return null;
  }

  if (!proxyRotation[username]) {
    proxyRotation[username] = { currentIndex: 0 };
  }

  return client.proxies[proxyRotation[username].currentIndex];
}

// –ü–∞—Ä—Å–∏–Ω–≥ –ø—Ä–æ–∫—Å–∏ —Å—Ç—Ä–æ–∫–∏
function parseProxy(proxyString) {
  const parts = proxyString.split(':');
  if (parts.length >= 4) {
    return {
      host: parts[0],
      port: parseInt(parts[1]),
      username: parts[2],
      password: parts[3]
    };
  }
  return null;
}

// API Endpoints

// –°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞
app.get('/status', (req, res) => {
  const stats = {
    status: 'running',
    port: PORT,
    tcp_proxy: `${TCP_DOMAIN}:${TCP_PORT}`,
    public_domain: PUBLIC_DOMAIN,
    uptime: process.uptime(),
    clients: Object.keys(clientsConfig).length,
    blacklisted_ips: ipBlacklist.size,
    timestamp: new Date().toISOString()
  };

  // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∫–ª–∏–µ–Ω—Ç–∞–º
  stats.client_stats = {};
  Object.keys(clientsConfig).forEach(username => {
    const client = clientsConfig[username];
    stats.client_stats[username] = {
      proxies: client.proxies ? client.proxies.length : 0,
      current_proxy_index: proxyRotation[username]?.currentIndex || 0
    };
  });

  res.json(stats);
});

// Health check
app.get('/health', (req, res) => {
  res.status(200).send('OK');
});

// –ü–æ–ª—É—á–∏—Ç—å IP –∫–ª–∏–µ–Ω—Ç–∞
app.get('/myip', (req, res) => {
  const clientIP = getClientIP(req);
  res.set({
    'Content-Type': 'text/plain',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  res.send(clientIP);
});

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –æ—Ç Telegram –±–æ—Ç–∞
app.post('/update-config', (req, res) => {
  try {
    const { clients } = req.body;
    
    if (!clients || typeof clients !== 'object') {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid clients configuration' 
      });
    }

    clientsConfig = clients;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–æ—Ç–∞—Ü–∏—é –¥–ª—è –Ω–æ–≤—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
    Object.keys(clientsConfig).forEach(username => {
      if (clientsConfig[username].proxies && clientsConfig[username].proxies.length > 0) {
        if (!proxyRotation[username]) {
          proxyRotation[username] = { currentIndex: 0 };
        }
      }
    });

    saveConfig();
    console.log('üì• Configuration received from Telegram Bot');
    console.log(`‚úÖ Updated configuration: ${Object.keys(clientsConfig).length} clients`);
    
    res.json({ 
      success: true, 
      message: 'Configuration updated successfully',
      clients: Object.keys(clientsConfig).length
    });
  } catch (error) {
    console.error('‚ùå Error updating config:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// üîÑ –†–£–ß–ù–ê–Ø –†–û–¢–ê–¶–ò–Ø –ü–†–û–ö–°–ò (–¥–ª—è Tampermonkey —Å–∫—Ä–∏–ø—Ç–∞)
app.post('/rotate-proxy', (req, res) => {
  try {
    const { username } = req.body;
    
    if (!username) {
      return res.status(400).json({ 
        success: false, 
        error: 'Username is required' 
      });
    }

    if (!clientsConfig[username]) {
      return res.status(404).json({ 
        success: false, 
        error: 'Client not found' 
      });
    }

    const client = clientsConfig[username];
    if (!client.proxies || client.proxies.length === 0) {
      return res.status(404).json({ 
        success: false, 
        error: 'No proxies available for this client' 
      });
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–æ—Ç–∞—Ü–∏—é –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    if (!proxyRotation[username]) {
      proxyRotation[username] = { currentIndex: 0 };
    }

    // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø—Ä–æ–∫—Å–∏
    proxyRotation[username].currentIndex = 
      (proxyRotation[username].currentIndex + 1) % client.proxies.length;
    
    const newProxy = client.proxies[proxyRotation[username].currentIndex];
    const currentIndex = proxyRotation[username].currentIndex;
    
    console.log(`üîÑ Manual proxy rotation for ${username}: ${newProxy} (index: ${currentIndex})`);
    
    res.json({ 
      success: true, 
      message: 'Proxy rotated successfully',
      username: username,
      current_proxy: newProxy,
      current_index: currentIndex,
      total_proxies: client.proxies.length
    });
    
  } catch (error) {
    console.error('‚ùå Error rotating proxy:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// üìã –ü–û–õ–£–ß–ò–¢–¨ –¢–ï–ö–£–©–ò–ô –ü–†–û–ö–°–ò (–±–µ–∑ —Ä–æ—Ç–∞—Ü–∏–∏)
app.get('/current-proxy/:username', (req, res) => {
  try {
    const { username } = req.params;
    
    if (!clientsConfig[username]) {
      return res.status(404).json({ 
        success: false, 
        error: 'Client not found' 
      });
    }

    const client = clientsConfig[username];
    if (!client.proxies || client.proxies.length === 0) {
      return res.status(404).json({ 
        success: false, 
        error: 'No proxies available for this client' 
      });
    }

    if (!proxyRotation[username]) {
      proxyRotation[username] = { currentIndex: 0 };
    }

    const currentIndex = proxyRotation[username].currentIndex;
    const currentProxy = client.proxies[currentIndex];
    
    res.json({ 
      success: true,
      username: username,
      current_proxy: currentProxy,
      current_index: currentIndex,
      total_proxies: client.proxies.length
    });
    
  } catch (error) {
    console.error('‚ùå Error getting current proxy:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// üéØ –£–°–¢–ê–ù–û–í–ò–¢–¨ –ö–û–ù–ö–†–ï–¢–ù–´–ô –ü–†–û–ö–°–ò –ü–û –ò–ù–î–ï–ö–°–£
app.post('/set-proxy-index', (req, res) => {
  try {
    const { username, index } = req.body;
    
    if (!username) {
      return res.status(400).json({ 
        success: false, 
        error: 'Username is required' 
      });
    }

    if (index === undefined || index === null) {
      return res.status(400).json({ 
        success: false, 
        error: 'Index is required' 
      });
    }

    if (!clientsConfig[username]) {
      return res.status(404).json({ 
        success: false, 
        error: 'Client not found' 
      });
    }

    const client = clientsConfig[username];
    if (!client.proxies || client.proxies.length === 0) {
      return res.status(404).json({ 
        success: false, 
        error: 'No proxies available for this client' 
      });
    }

    const proxyIndex = parseInt(index);
    if (proxyIndex < 0 || proxyIndex >= client.proxies.length) {
      return res.status(400).json({ 
        success: false, 
        error: `Invalid index. Must be between 0 and ${client.proxies.length - 1}` 
      });
    }

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –∏–Ω–¥–µ–∫—Å
    if (!proxyRotation[username]) {
      proxyRotation[username] = { currentIndex: 0 };
    }
    
    proxyRotation[username].currentIndex = proxyIndex;
    const selectedProxy = client.proxies[proxyIndex];
    
    console.log(`üéØ Set proxy index for ${username}: ${selectedProxy} (index: ${proxyIndex})`);
    
    res.json({ 
      success: true, 
      message: 'Proxy index set successfully',
      username: username,
      current_proxy: selectedProxy,
      current_index: proxyIndex,
      total_proxies: client.proxies.length
    });
    
  } catch (error) {
    console.error('‚ùå Error setting proxy index:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// üìä –ü–û–õ–£–ß–ò–¢–¨ –í–°–ï –ü–†–û–ö–°–ò –ö–õ–ò–ï–ù–¢–ê
app.get('/proxies/:username', (req, res) => {
  try {
    const { username } = req.params;
    
    if (!clientsConfig[username]) {
      return res.status(404).json({ 
        success: false, 
        error: 'Client not found' 
      });
    }

    const client = clientsConfig[username];
    if (!client.proxies || client.proxies.length === 0) {
      return res.status(404).json({ 
        success: false, 
        error: 'No proxies available for this client' 
      });
    }

    if (!proxyRotation[username]) {
      proxyRotation[username] = { currentIndex: 0 };
    }

    res.json({ 
      success: true,
      username: username,
      proxies: client.proxies,
      current_index: proxyRotation[username].currentIndex,
      total_proxies: client.proxies.length
    });
    
  } catch (error) {
    console.error('‚ùå Error getting proxies:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô HTTP –ø—Ä–æ–∫—Å–∏ endpoint
app.use('/proxy', authenticateClient, (req, res, next) => {
  const username = req.clientUsername;
  const proxy = getCurrentProxy(username); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–π –ø—Ä–æ–∫—Å–∏ –±–µ–∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ä–æ—Ç–∞—Ü–∏–∏
  
  if (!proxy) {
    return res.status(503).json({ 
      error: 'No proxies available for this client' 
    });
  }

  const parsedProxy = parseProxy(proxy);
  if (!parsedProxy) {
    return res.status(500).json({ 
      error: 'Invalid proxy configuration' 
    });
  }

  console.log(`üîÑ HTTP Proxy for ${username}: ${parsedProxy.host}:${parsedProxy.port}`);

  // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ–∫—Å–∏ middleware –¥–ª—è HTTP –∑–∞–ø—Ä–æ—Å–æ–≤
  const proxyMiddleware = createProxyMiddleware({
    target: `http://${parsedProxy.host}:${parsedProxy.port}`,
    changeOrigin: true,
    pathRewrite: {
      '^/proxy': ''
    },
    onError: (err, req, res) => {
      console.error(`‚ùå HTTP Proxy error for ${username}:`, err.message);
      if (!res.headersSent) {
        res.status(502).json({ error: 'Proxy connection failed', details: err.message });
      }
    },
    onProxyReq: (proxyReq, req, res) => {
      // –î–æ–±–∞–≤–ª—è–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –¥–ª—è upstream –ø—Ä–æ–∫—Å–∏
      const proxyAuth = Buffer.from(`${parsedProxy.username}:${parsedProxy.password}`).toString('base64');
      proxyReq.setHeader('Proxy-Authorization', `Basic ${proxyAuth}`);
      
      console.log(`‚û°Ô∏è HTTP Proxying ${req.method} ${req.url} for ${username} via ${parsedProxy.host}:${parsedProxy.port}`);
    },
    onProxyRes: (proxyRes, req, res) => {
      console.log(`‚¨ÖÔ∏è HTTP Response ${proxyRes.statusCode} for ${req.clientUsername}`);
    }
  });

  proxyMiddleware(req, res, next);
});

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–ª—ç–∫–ª–∏—Å—Ç–æ–º (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
app.post('/blacklist/add', (req, res) => {
  const { ip, admin_key } = req.body;
  
  if (admin_key !== process.env.ADMIN_KEY) {
    return res.status(403).json({ error: 'Admin access required' });
  }

  if (!ip) {
    return res.status(400).json({ error: 'IP address required' });
  }

  ipBlacklist.add(ip);
  saveBlacklist();
  console.log(`üö´ Added to blacklist: ${ip}`);
  
  res.json({ success: true, message: `IP ${ip} added to blacklist` });
});

app.post('/blacklist/remove', (req, res) => {
  const { ip, admin_key } = req.body;
  
  if (admin_key !== process.env.ADMIN_KEY) {
    return res.status(403).json({ error: 'Admin access required' });
  }

  if (!ip) {
    return res.status(400).json({ error: 'IP address required' });
  }

  ipBlacklist.delete(ip);
  saveBlacklist();
  console.log(`‚úÖ Removed from blacklist: ${ip}`);
  
  res.json({ success: true, message: `IP ${ip} removed from blacklist` });
});

// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –±–ª—ç–∫–ª–∏—Å—Ç–∞
app.get('/blacklist', (req, res) => {
  const { admin_key } = req.query;
  
  if (admin_key !== process.env.ADMIN_KEY) {
    return res.status(403).json({ error: 'Admin access required' });
  }

  res.json({ blacklist: [...ipBlacklist] });
});

// ‚úÖ –î–û–ë–ê–í–õ–Ø–ï–ú TCP –ü–†–û–ö–°–ò –§–£–ù–ö–¶–ò–û–ù–ê–õ–¨–ù–û–°–¢–¨
const server = http.createServer(app);

// –û–±—Ä–∞–±–æ—Ç–∫–∞ CONNECT –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è TCP/HTTPS –ø—Ä–æ–∫—Å–∏
server.on('connect', (req, clientSocket, head) => {
  console.log(`üîå CONNECT request: ${req.url}`);
  console.log(`üîç CONNECT headers:`, req.headers);
  
  const username = authenticateConnect(req);
  if (!username) {
    console.log('‚ùå CONNECT: Authentication failed');
    clientSocket.write('HTTP/1.1 407 Proxy Authentication Required\r\nProxy-Authenticate: Basic realm="Proxy"\r\n\r\n');
    clientSocket.end();
    return;
  }

  const proxy = getCurrentProxy(username); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–π –ø—Ä–æ–∫—Å–∏ –±–µ–∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ä–æ—Ç–∞—Ü–∏–∏
  if (!proxy) {
    console.log(`‚ùå CONNECT: No proxy available for ${username}`);
    clientSocket.write('HTTP/1.1 503 Service Unavailable\r\n\r\n');
    clientSocket.end();
    return;
  }

  const parsedProxy = parseProxy(proxy);
  if (!parsedProxy) {
    console.log(`‚ùå CONNECT: Invalid proxy config for ${username}`);
    clientSocket.write('HTTP/1.1 500 Internal Server Error\r\n\r\n');
    clientSocket.end();
    return;
  }

  console.log(`üîÑ TCP Proxy for ${username}: ${parsedProxy.host}:${parsedProxy.port} -> ${req.url}`);

  // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ upstream –ø—Ä–æ–∫—Å–∏
  const proxySocket = net.createConnection(parsedProxy.port, parsedProxy.host);
  
  proxySocket.on('connect', () => {
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º CONNECT –∑–∞–ø—Ä–æ—Å –∫ upstream –ø—Ä–æ–∫—Å–∏
    const proxyAuth = Buffer.from(`${parsedProxy.username}:${parsedProxy.password}`).toString('base64');
    const connectRequest = `CONNECT ${req.url} HTTP/1.1\r\nProxy-Authorization: Basic ${proxyAuth}\r\n\r\n`;
    
    console.log(`üì§ Sending CONNECT to upstream: ${parsedProxy.host}:${parsedProxy.port}`);
    proxySocket.write(connectRequest);
  });

  let headersParsed = false;
  proxySocket.on('data', (data) => {
    if (!headersParsed) {
      const response = data.toString();
      console.log(`üì• Upstream response: ${response.split('\r\n')[0]}`);
      
      if (response.includes('200 Connection established') || response.includes('200 OK')) {
        console.log(`‚úÖ TCP Tunnel established for ${username}`);
        clientSocket.write('HTTP/1.1 200 Connection Established\r\n\r\n');
        headersParsed = true;
        
        // –ù–∞—á–∏–Ω–∞–µ–º —Ç—É–Ω–Ω–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        clientSocket.pipe(proxySocket);
        proxySocket.pipe(clientSocket);
      } else {
        console.log(`‚ùå TCP Proxy connection failed for ${username}: ${response.split('\r\n')[0]}`);
        clientSocket.write('HTTP/1.1 502 Bad Gateway\r\n\r\n');
        clientSocket.end();
        proxySocket.end();
      }
    }
  });

  proxySocket.on('error', (err) => {
    console.error(`‚ùå TCP Proxy error for ${username}:`, err.message);
    if (!headersParsed) {
      clientSocket.write('HTTP/1.1 502 Bad Gateway\r\n\r\n');
    }
    clientSocket.end();
  });

  clientSocket.on('error', (err) => {
    console.error(`‚ùå Client socket error for ${username}:`, err.message);
    proxySocket.end();
  });
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
server.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ FULL Proxy server (HTTP + TCP) running on port ${PORT}`);
  console.log(`üåê TCP Proxy: ${TCP_DOMAIN}:${TCP_PORT}`);
  console.log(`üåê Public Domain: ${PUBLIC_DOMAIN}`);
  console.log('ü§ñ Managed by Telegram Bot');
  console.log('üîÑ Manual proxy rotation: ENABLED');
  console.log('‚ö° Tampermonkey control: READY');
  console.log('‚úÖ Server started successfully');
  
  // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
  loadConfig();
  loadBlacklist();
  
});
